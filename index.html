<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cube XR - SAE 4.02</title>
  <!-- Import de A-Frame -->
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <!-- Import de aframe-extras pour l'effet ocean -->
  <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.2.0/dist/aframe-extras.min.js"></script>

  <!-- Composant personnalis√© pour l'eau avec effet fluide Three.js -->
  <script>
    AFRAME.registerComponent('water-shader', {
      schema: {
        color: { type: 'color', default: '#0077be' },
        opacity: { type: 'number', default: 0.6 },
        speed: { type: 'number', default: 1.0 },
        waveHeight: { type: 'number', default: 0.1 },
        waveFrequency: { type: 'number', default: 2.0 }
      },

      init: function () {
        const data = this.data;
        const el = this.el;

        // Cr√©er une g√©om√©trie plane avec beaucoup de subdivisions pour les vagues
        const geometry = new THREE.PlaneGeometry(10, 10, 64, 64);

        // Mat√©riau avec transparence
        const material = new THREE.MeshStandardMaterial({
          color: new THREE.Color(data.color),
          transparent: true,
          opacity: data.opacity,
          side: THREE.DoubleSide,
          metalness: 0.1,
          roughness: 0.3
        });

        // Cr√©er le mesh
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.rotation.x = -Math.PI / 2; // Horizontal

        // Ajouter √† la sc√®ne
        el.setObject3D('mesh', this.mesh);

        // Stocker les positions initiales des vertices
        this.originalPositions = geometry.attributes.position.array.slice();
        this.time = 0;
      },

      tick: function (time, deltaTime) {
        if (!this.mesh) return;

        const data = this.data;
        this.time += deltaTime * 0.001 * data.speed;

        const positions = this.mesh.geometry.attributes.position.array;
        const original = this.originalPositions;

        // Animer chaque vertex pour cr√©er l'effet de vagues
        for (let i = 0; i < positions.length; i += 3) {
          const x = original[i];
          const y = original[i + 1];

          // Cr√©er des vagues sinuso√Ødales multiples
          const wave1 = Math.sin(x * data.waveFrequency + this.time) * data.waveHeight;
          const wave2 = Math.sin(y * data.waveFrequency * 0.8 + this.time * 1.2) * data.waveHeight * 0.5;
          const wave3 = Math.sin((x + y) * data.waveFrequency * 0.5 + this.time * 0.8) * data.waveHeight * 0.3;

          // Appliquer la hauteur de vague sur l'axe Z (qui devient Y apr√®s rotation)
          positions[i + 2] = wave1 + wave2 + wave3;
        }

        this.mesh.geometry.attributes.position.needsUpdate = true;
        this.mesh.geometry.computeVertexNormals();
      }
    });
  </script>

  <style>
    #ar-button {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 15px 30px;
      font-size: 18px;
      background: #e74c3c;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      z-index: 9999;
    }

    #ar-button:hover {
      background: #c0392b;
    }

    #ar-overlay {
      position: fixed;
      bottom: 20px;
      left: 0;
      right: 0;
      display: flex;
      justify-content: center;
      z-index: 9999;
    }

    /* Rendre la sc√®ne/canvas transparente afin que le passthrough du casque soit visible derri√®re */
    html,
    body,
    a-scene,
    canvas {
      background: transparent !important;
    }
  </style>
</head>

<body>
  <!-- Bouton pour entrer en mode AR -->
  <div id="ar-overlay">
    <button id="ar-button">Entrer en AR ü•Ω</button>
  </div>

  <!-- Sc√®ne A-Frame avec configuration WebXR native pour AR -->
  <a-scene webxr="mode: immersive-ar; referenceSpaceType: local-floor; overlayElement: #ar-overlay;"
    renderer="colorManagement: true; alpha: true; antialias: true; sortObjects: true" background="color: transparent">

    <!-- Ancre monde : tous les objets 3D sont enfants de cette entit√© pour rester fixes dans l'espace r√©el -->
    <a-entity id="world-anchor">

      <!-- Cube rouge - visible dans le monde r√©el -->
      <a-box position="0 1.5 -2" rotation="0 45 0" color="#e74c3c" width="0.5" height="0.5" depth="0.5"
        animation="property: rotation; to: 0 405 0; dur: 5000; easing: linear; loop: true">
      </a-box>

      <!-- EFFET D'EAU QUI MONTE avec shader Three.js (positionn√©e dans le monde, pas au niveau de la cam√©ra) -->
      <a-entity id="water-surface" position="0 0 -2"
        animation="property: position; from: 0 0 -2; to: 0 2.5 -2; dur: 10000; easing: easeInOutQuad">

        <!-- Surface d'eau avec effet de vagues fluides -->
        <a-entity id="water-fluid"
          water-shader="color: #0088cc; opacity: 0.65; speed: 1.5; waveHeight: 0.08; waveFrequency: 1.5">
        </a-entity>

        <!-- Deuxi√®me couche d'eau plus claire pour la profondeur -->
        <a-entity position="0 -0.05 0"
          water-shader="color: #00aaff; opacity: 0.3; speed: 0.8; waveHeight: 0.05; waveFrequency: 2.0">
        </a-entity>
      </a-entity>

      <!-- Particules de bulles qui montent avec l'eau -->
      <a-entity id="bubbles" position="0 0 -2">
        <a-sphere position="-0.5 0.2 0" radius="0.05" color="#ffffff" opacity="0.5"
          animation="property: position; from: -0.5 0.2 0; to: -0.5 2.7 0; dur: 8000; easing: linear"></a-sphere>
        <a-sphere position="0.3 0.1 -0.5" radius="0.03" color="#ffffff" opacity="0.4"
          animation="property: position; from: 0.3 0.1 -0.5; to: 0.3 2.6 -0.5; dur: 7000; easing: linear; delay: 500"></a-sphere>
        <a-sphere position="0 0.3 0.3" radius="0.04" color="#ffffff" opacity="0.5"
          animation="property: position; from: 0 0.3 0.3; to: 0 2.8 0.3; dur: 9000; easing: linear; delay: 1000"></a-sphere>
        <a-sphere position="0.7 0.15 -0.2" radius="0.035" color="#ffffff" opacity="0.4"
          animation="property: position; from: 0.7 0.15 -0.2; to: 0.7 2.65 -0.2; dur: 7500; easing: linear; delay: 300"></a-sphere>
        <a-sphere position="-0.3 0.25 0.5" radius="0.045" color="#ffffff" opacity="0.5"
          animation="property: position; from: -0.3 0.25 0.5; to: -0.3 2.75 0.5; dur: 8500; easing: linear; delay: 700"></a-sphere>
      </a-entity>

      <!-- Lumi√®res -->
      <a-light type="ambient" color="#ffffff" intensity="0.6"></a-light>
      <a-light type="directional" color="#ffffff" intensity="0.8" position="1 2 1"></a-light>
      <!-- Lumi√®re bleut√©e sous l'eau -->
      <a-light type="point" color="#0088ff" intensity="0.5" position="0 0.5 -2"></a-light>

    </a-entity>

    <!-- Cam√©ra XR (sans rig parent pour √©viter les d√©calages en AR) -->
    <a-camera position="0 1.6 0"></a-camera>
  </a-scene>

  <script>
    // Bouton pour lancer le mode AR avec la m√©thode native A-Frame
    const arButton = document.getElementById('ar-button');
    const scene = document.querySelector('a-scene');

    arButton.addEventListener('click', async function () {
      // V√©rifier si WebXR AR est support√©
      if (!navigator.xr) {
        alert('WebXR non support√© sur ce navigateur');
        return;
      }

      const isArSupported = await navigator.xr.isSessionSupported('immersive-ar');

      if (!isArSupported) {
        alert('Mode AR non support√©. Utilisez un Quest 3 ou un appareil compatible.');
        return;
      }

      try {
        // Utiliser la m√©thode native d'A-Frame pour entrer en AR
        // Cela g√®re correctement le reference space et l'ancrage spatial
        scene.enterAR();
        arButton.style.display = 'none';

        // √âcouter la sortie du mode AR
        scene.addEventListener('exit-vr', function onExitAR() {
          arButton.style.display = 'block';
          scene.removeEventListener('exit-vr', onExitAR);
        });

        console.log('Mode AR activ√© - passthrough actif !');

      } catch (err) {
        console.error('Erreur lors du lancement AR:', err);
        alert('Erreur: ' + err.message);
      }
    });

    // Cacher le bouton si AR non support√©
    scene.addEventListener('loaded', async function () {
      if (navigator.xr) {
        const isArSupported = await navigator.xr.isSessionSupported('immersive-ar');
        if (!isArSupported) {
          arButton.textContent = 'AR non disponible';
          arButton.disabled = true;
        }
      } else {
        arButton.textContent = 'WebXR non support√©';
        arButton.disabled = true;
      }
    });
  </script>
</body>

</html>